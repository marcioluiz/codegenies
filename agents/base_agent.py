"""
base_agent.py

This file defines the classes for the different agents 
used in the project: Analyst, SquadLeader, Developer and Tester. 
Each agent uses a large language model (LLM) 
specific to carry out your tasks.

Classes:

- Analyst: Responsible for generating initial reports and task backlogs.
  - __init__(self, model, properties_file, interactive=False): Initializes the Analyst agent.
    - model (Ollama): Language model to be used by the analyst.
    - properties_file (str): Path to the project properties file.
    - interactive (bool): Defines whether the process will be interactive.

  - generate_report(self): Generates the initial project report.

- SquadLeader: Coordinates the team and generates reports and task backlogs for developers and testers.
  - __init__(self, model, interactive=False): Initializes the SquadLeader agent.
    - model (Ollama): Language model to be used by the team leader.
    - interactive (bool): Defines whether the process will be interactive.

  - generate_general_report(self, analyst_report): Generates the project's general report.
    - analyst_report (str): Initial report generated by the analyst.

  - generate_backend_backlog(self, analyst_report): Generates the backend task backlog.
    - analyst_report (str): Initial report generated by the analyst.

  - generate_frontend_backlog(self, analyst_report): Generates the frontend task backlog.
    - analyst_report (str): Initial report generated by the analyst.

  - generate_test_backlog(self, analyst_report): Generates the backlog of testing tasks.
    - analyst_report (str): Initial report generated by the analyst.

        • Developer: Responsible for implementing development tasks according to the generated backlog.
            • init(self, model, name, interactive=False): Initializes the Developer agent.
                • model (Ollama): Language model to be used by the developer.
                • name (str): Developer name.
                • interactive (bool): Defines whether the process will be interactive.
            • Tester: Responsible for carrying out tests and validating implementations.
                • init(self, model, interactive=False): Initializes the Tester agent.
                    • model (Ollama): Language model to be used by the tester.
                    • interactive (bool): Defines whether the process will be interactive.
"""
import inspect
from main import translate_string

class BaseAgent:
    def __init__(self, name, llm, language, interactive):
        self.name = name
        self.llm = llm
        self.language = language
        self.interactive = interactive
        self.output = ""

    def evaluate(self, prompt):
        try:
            print(f"\n{translate_string("base_agent", "base_agent_evaluating_prompt", self.language).format(name=self.name, prompt=prompt)}")
            output = self.llm.invoke(prompt)
            print(f"{translate_string("base_agent", "base_agent_model_response", self.language).format(output=output)}")
            self.output = output
            return output
        except Exception as e:
            print(f"{translate_string("base_agent", "base_agent_error_evaluating_prompt", self.language).format(error=e)}")
            return None

    def interact(self, prompt):
        """
        Interacts with the user to refine the response.
        Args:
            initial_response (str): The initial response of the language model.
        Returns:
            str: The refined answer.
        """
        response = prompt
        print(f"\n{translate_string("base_agent", "base_agent_interacting_with_user", self.language).format(name=self.name)}")
        interact = input(f"\n{translate_string("base_agent", "base_agent_prompt_alter_response", self.language)}")
        if interact.lower() == 's':
            response = ''
            user_input = input(f"\n{translate_string("base_agent", "base_agent_human_action_needed", self.language)}")
            refined_prompt = user_input + "\n"  + prompt
            response = self.evaluate(refined_prompt)
        else:
            print(f"\n{translate_string("base_agent", "base_agent_interaction_ended", self.language)}")
            user_input = None
            response = prompt
            
        return response

    def get_source_code(self):
        return inspect.getsource(self.__class__)
